---
title: "Exercise 09"
output:
  pdf_document: default
  html_document: default
---

```{r setup, echo = FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ape)

# Load data import, wrangling, and plotting tools from the Tidyverse. 
# See https://r4ds.had.co.nz/ for more
library(tidyverse)

library(magrittr)

```


## Introduction

The goals of this exercise are to:
- Perform time-calibrated phylogenetic inference using revbayes


[RevBayes](https://revbayes.github.io) is a very flexible tool for phylogenetic analyses. You have extensive control over which features of your model are constant, deterministic, or stochastic. This allows RevBayes to do a standard Bayesian phylogenetic inference, but it can also do much more including time calibration, ancestral character state reconstruction, and phylogenetic comparative analyses. 

This flexibility comes with greater complexity than many other tools. For example, the models are explicitly specified rather than just called by name (eg GTR). These configurations are far too extensive to list at the command line when you call the program, as we did for seqgen and iqtree. Instead, they are placed in RevBayes script files that typically end with the file extension `.Rev`. These files contain a series of command written in RevBayes' own language, which has a  [syntax](https://revbayes.github.io/tutorials/intro/rev.html) similar to R. For an introduction on how to specify models and implement analyses see the documentation on  [Getting Started with RevBayes tutorial](https://revbayes.github.io/tutorials/intro/getting_started.html). For an overview of all the commands see the [documentation](https://revbayes.github.io/documentation/).


A typical RevBayes script has commands that load the data, set up the model, define the analysis, run the analysis, and control what is in the output and where it goes. For routine analyses you can modify the basics of existing files, changing the input and output files for example. For more more specialized analyses you can extensively revise and expand these files, or write them from scrap.

There is a series of detailed [tutorials](https://revbayes.github.io/tutorials/) that serve as a great starting point for using RevBayes. This exercise is based off of the [Nucleotide substitution models](https://revbayes.github.io/tutorials/ctmc/) tutorial. There are a few variations to get it running on the cluster. 


## Getting set up

We are going to use a third party tool, [FigTree](https://github.com/rambaut/figtree/releases), to view the phylogenies.

Please also install [Tracer]( https://github.com/beast-dev/tracer/releases/tag/v1.7.2), a tool for examining posterior distributions

You may need to also install [java](https://www.java.com/en/download/) to get FigTree and Tracer running. If you have a Mac with Apple Silicon (an M series chip), be sure to install the version of Java for ARM64 rather than Intel.

If you prefer not to install these tools, you can write simple R scripts to read in the output files and plot the results.

## Getting the files

This exercise follows another existing tutorial -- [Molecular dating](https://revbayes.github.io/tutorials/dating/) by Rachel Warnock, Sebastian HÃ¶hna, Tracy Heath, April Wright and Walker Pett. That tutorial is split into 5 parts, each of which they refer to as an exercise. We will work through the first 4.

Rather than have everyone retype all the exercises, I provide all the job and script files that are needed.

There will be a few folders in your exercise directory:

- The job files for launching the run on the cluster
- `scripts` directory, with all the RevBayes scripts. These are called form the job files.
- `data` the input data
- `output` the results generated by RevBayes. It will create the folder if it doesn't already exist.

## Your tasks

Each [exercise](https://revbayes.github.io/tutorials/dating/) is broken into two parts - the top part explains how to type things in and run the analyses, and then a final section called `Examining the output` discusses the results.

Here is what you will do for each of the first 4 exercises:
1. Read through the top part, referring to the files in `scripts/`, to get a general idea of the goal and how it is accomplished.
2. Carefully walk through all the steps in `Examining the output`, using Tracer, FigTree, and the other indicated tools to explore and examine the results.
3. Answer the prompts below.

### 1. Molecular dating, The global molecular clock model

Here, they used molecular sequence data to infer relative speciation assuming global clock model. This global clock model assumes the rate of substitution is constant over time and across the tree.

> **_Problem 1:_** (2 points) 

1. Open up the bears_global.log file in Tracer (use File > Import Trace File...). Select the `speciation_rate` trace in the lower left pane. Inspect the posterior samples for `speciation_rate` with the Estimates, Marginal Density, and Trace views in the upper right. Answer the following questions.

- What was the estimated (mean) value?

- What was the expected prior distribution on this value? How does the posterior distribution compare to that?

- Does the trace view suggest that the MCMC was well mixed?



2. Open up the bears_global.mcc.tre file in FigTree and make sure you can see the Node Labels, and that Node Ages are selected is the node labels. How would you interpret these numbers?



### 2. Molecular dating, The uncorrelated exponential relaxed clock model

> **_Problem 1:_** (2 points) 

1. Open up the bears_relaxed_exponential.log in Tracer. In the `Traces:` window on the lower left you can see all the rates estimates for the branch-specific rates. They are labeled `branch_rates[]`, with one for each branch.

- Take a look at the mean for each `branch_rates[]` value. How different are these? 

- What does this suggest about the global clock we used in the previous analysis?



2. Open up the bears_relaxed_exponential.mcc.tre file in FigTree and make sure you can see the Node Labels. What is different about this tree compared to the global tree in terms of topology, node labels, and branch labels. Why did changing the model make these differences?


## Submit

Submit this file, with the answers to the prompts, on canvas.

